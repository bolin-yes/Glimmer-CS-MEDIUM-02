# 课前准备-文件操作
时间不够写不出来了，被体育课硬控了，学长你看着给分吧（ak不完力）
# 任务1
了解定点数c语言表示、进制转换函数

定点数，就是小数点位置固定的数，也就是说小数点后面的位数是固定的。定点数如果要表示整数或小数则分为三种情况。若为纯整数，小数点在最后一位，忽略不写。纯小数，小数点固定在最高位。整数小数混合，小数点固定在某个位置。

请用你的编辑器分别书写如下C语言代码并运行
```
#include <sdtio.h>
int main(){
    float a=0.1;
    float b=0.2;
    float c=a+b;
    printf("%f",c);
    return 0;
}
```
```
#include <stdio.h>
int main(){
    float a=0.1;
    float b=0.2;
    float c=a+b;
    printf("%.10f",c);
    return 0;
}
```
会发现第二个运行结果为0.3000000119， 所以出现了经典现象0.1+0.2>0.3

任务

## 1.为什么会出现这样的现象？
#### 计算机是通过二进制计算的，如果我们在二进制的视角来看待上面问题，就很容易发现问题了。
例如：把「0.1」转成二进制的表示，然后还原成十进制，就能看出问题。
小数转二进制，是通过除法进行的，至于为什么我通过查阅资料有一些理解，十进制转二进制下列例子，通过将除数变为二进制，结果很自然的也就转变为二进制，但是1并不能被1010这个二进制数除尽，就变成了无限循环小数，，但计算机的储存数字位数并不是无限的，所以最后的精度会有误差，因此不管是单精度还是双精度浮点数都会有误差，当计算所需精度越大，这种误差就会越明显
0.1 = 1 ÷ 10
二进制就是要算
1 ÷ 1010
最终0.1转二进制是：
0.0001100110011001100110011001100110011001100110011001101

float的精度为7~8位有效数字
double的精度为16~17位有效数字
二进制表示
1.1+0.1 = 1.0011001100110011001100110011001100110011001100110100
十进制展示
1.1+0.1 = 1.2000000000000002
## 2.该如何获得精确值呢？请阅读相关资料后提交于markdown文档。
#### 可以了解java中的BigInteger和BigDecimal类，python中的Decimal块和C语言gmp.h头文件；
BigInteger类在内部是通过一个整数数组来存储大整数的，
然后加法就是对应位数相加，乘法和上一题一样也算是c[i+j]=a[i]*b[j]这和我做的上一题，大数运算的部分类似

BigDecimal由一个整数部分（使用BigInteger来表示）和一个小数位数（scale）组成，scale明确规定了小数的位数，以减小误差

Python 中的Decimal模块原理：和BigDecimal类似，在进行加法时，首先将两个Decimal对象的小数点对齐

C 语言中的gmp.h头文件原理：加法类似于BigDecimal，乘法根据资料说是和傅里叶变换有关（没学不知道捏）